#!/usr/bin/env python3

import os
import io

from ultrasonics import logs

log = logs.create_log(__name__)

handshake = {
    "name": "local playlists",
    "description": "interface with all local .m3u playlists in a directory",
    "type": [
        "inputs",
        "outputs"
    ],
    "mode": [
        "playlists"
    ],
    "version": 0.1,
    "settings": [
        {
            "type": "string",
            "value": "Local playlists (such as .m3u files) include paths directly to the song."
        },
        {
            "type": "string",
            "value": """If the playlists were generated by a different computer/server to the one you're running
            ultrasonics üéß on currently, the paths saved in the playlist cannot be used by ultrasonics
            to find the song file."""
        },
        {
            "type": "string",
            "value": """Therefore, you need to provide a prepend for your playlist music files, and the
            path relative to ultrasonics."""
        },
        {
            "type": "string",
            "value": "This prepend is the longest path üìè common to all audio files."
        },
        {
            "type": "text",
            "label": "Local Playlist Prepend",
            "name": "local_prepend",
            "value": "D:/Music"
        },
        {
            "type": "text",
            "label": "ultrasonics Prepend",
            "name": "ultrasonics_prepend",
            "value": "/mnt/music library/music"
        },

    ]
}

supported_playlist_extensions = [
    ".m3u"
]

supported_audio_extensions = [
    ".mp3",
    ".m4a"
]


def run(settings_dict, database, songs_dict=None):
    """
    if songs_dict is not supplied, this is an input plugin. it must return a songs_dict
    if songs_dict is supplied, it can be a modifier (and also returns songs_dict) or an output (and does not return anything)
    """

    def remove_prepend(path):
        """
        Remove any playlist local music files prepend, so only the path relative to the user's music directory is left.
        """

        if database["local_prepend"]:
            return path.replace(database["local_prepend"], '').lstrip("/").lstrip("\\")
        else:
            return path

    def append_prepend(path):
        """
        Re-append the playlist local music files prepend, so the track can be saved back into the playlist.
        """
        return database["local_prepend"] + path

    def convert_path(path):
        if convert_path:
            unix = os.name != "nt"

            if unix:
                return path.replace("\\", "/")
            else:
                return path.replace("/", "\\")

    path = settings_dict["dir"]
    playlists = []

    # Check if file paths are unix or nt (windows)
    path_convert = False
    ultrasonics_unix = database["ultrasonics_prepend"].startswith("/")
    local_unix = database["local_prepend"].startswith("/")

    if ultrasonics_unix != local_unix:
        log.debug(
            "Ultrasonics paths and local playlist paths do not use the same separators!")
        path_convert = True

    if "recursive" in settings_dict:
        # Recursive mode
        for root, _, files in os.walk(path):
            for item in files:
                playlists.append({
                    "name": os.path.splitext(item)[0],
                    "path": os.path.join(root, item)
                })

    else:
        # Non recursive mode
        files = os.listdir(path)
        for item in files:
            playlists.append({
                "name": os.path.splitext(item)[0],
                "path": item
            })

    # Remove any files which don't have a supported extension
    playlists = [item for item in playlists if os.path.splitext(item["path"])[
        1] in supported_playlist_extensions]

    if not songs_dict:
        "Input mode"

        songs_dict = []

        for playlist in playlists:

            songs_dict_entry = {
                "name": playlist["name"],
                "songs": []
            }

            songs = io.open(playlist["path"], 'r',
                            encoding='utf8').read().splitlines()

            for song in songs:

                # Skip .m3u tags beginning with "#"
                if song.startswith("#"):
                    continue

                path = remove_prepend(song)
                path = convert_path(path)
                path = os.path.join(database["ultrasonics_prepend"], path)

                # Skip files which don't exist
                if not os.path.isfile(path):
                    continue

                try:
                    _, ext = os.path.splitext(path)

                    # Skip files which are not supported
                    if ext not in supported_audio_extensions:
                        continue

                    if ext == ".mp3":
                        from mutagen.easyid3 import EasyID3

                        tags = EasyID3(path)

                        temp_song_dict = {}

                        for field in ["title", "artist", "album", "date", "isrc", "tracknumber"]:
                            try:
                                temp_song_dict[field] = tags[field][0]
                            except KeyError:
                                pass

                        # Let's use the below two for the local files matcher
                        # acoustid_id = tags["acoustid_id"]
                        # acoustid_fingerprint = tags["acoustid_fingerprint"]

                    if ext == ".m4a":
                        from mutagen.mp4 import MP4

                        tags = MP4(path)

                        temp_song_dict = {}

                        for field, ident in {"title": "\xa9nam", "artist": "\xa9ART", "album": "\xa9alb", "date": "\xa9day"}.items():
                            try:
                                temp_song_dict[field] = tags[ident][0]
                            except KeyError:
                                pass

                        # # Correct date format
                        # if temp_song_dict["date"]:

                except Exception as e:
                    log.error(f"Could not load tags from song: {path}")
                    log.error(e)

                temp_song_dict["location"] = path

                songs_dict_entry["songs"].append(temp_song_dict)

            songs_dict.append(songs_dict_entry)

        return songs_dict

    else:
        "Output mode"
        print(settings_dict)


def builder(database=None):
    """
    This function is run when the plugin is selected within a flow. It may query names of playlists or how many recent songs to include in the list.
    It returns a dictionary containing the settings the user must input in this case.

    Inputs: Persistent database settings for this plugin
    """

    settings_dict = [
        {
            "type": "string",
            "value": f"""‚ö†Ô∏è Only {', '.join(supported_playlist_extensions)} extensions are supported for playlists,
            and {', '.join(supported_audio_extensions)} extensions are supported for audio files.
            Unsupported files will be ignored."""
        },
        {
            "type": "text",
            "label": "Directory",
            "name": "dir",
            "value": "/mnt/music library/playlists"
        },
        {
            "type": "checkbox",
            "label": "Recursive",
            "name": "recursive",
            "value": "recursive",
            "id": "recursive"
        },
        {
            "type": "string",
            "value": "Enabling recursive mode will search all subfolders for more playlists."
        }
    ]

    return settings_dict
